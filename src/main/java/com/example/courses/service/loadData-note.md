## Алгоритм метода сохранения массива данных курсов валют loadCoursesData

### Вариант 1
1. Проверка аргумента на null
2. Проверка аргумента на наличие данных
3. Поэлементная обработка массива <br>Если курс некорректен технически, игнорируем элемент<br>Если курс слишком старый,
   игнорируем элемент <br>Опеределяем i - индекс для вставки данных курса - текущего элемента <br>Получаем "голову" (
   самые старые
   элементы) в виде списка (массива), содержащего элементы хранилища с индексами от 1 (самый старый элемент от 0 уже не
   актуален) до i-1 <br>Получаем "хвост" (самые новые элементы) от (i + 1)-го элемента до (size-1)-го элемента<br>
   Собираем конкатенацию "голова" + новый элемент + "хвост" и загружаем в хранилище<br>Инкрементируем счетчик
   загруженных элементов
5. Анализируем результаты обработки: если удалось загрузить все элементы, возвращаем сообщение SUCCESS, если нет,
   возвращаем сообщение об ошибке с количеством полученных и успешно загруженных элементов 

Оценка варианта 1 Алгоритма пакетного сохранения данных курсов валют (сохранения массива данных курсов)
Много действий на уровне сервиса
Функциональность хранилища на основе очереди не используется для пакетного сохранения данных курсов валют

Вариант 2
Реализовать логику, необходимую для сохранения массива данных курсов валют, на уровне хранилища. В частности, необходимо
реализовать сохранение курса с произвольной датировкой, которая задана заранее

Соображения о реализации хранилища
Функционал циклической очереди CircularFifoQueue используется только для сохранения новых сущностей курса валюты.
Если мы получаем курс с произвольной датой, то необходимо написать логику для его сохранения.
Очередь не подходит для этого, поскольку для нашего приложения имеет значение датировка курсов валют,
а не порядок сохранения сущностей курсов

Идея реализации хранилища:

Map<CurrencyId,Map<>